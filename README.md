---
title: 设计模式系列：概况  
date: 2017/10/25 11:59:47  
categories: [java,设计模式]
tags: [java,设计模式]
---

### 概况
> 设计模式是对于Java变成过程中遇到的特定抽象场景总结出的一套通用方法,常用的用23种几年模式。

### 分类
总体来说设计模式分为三大类：
- 创建型模式，共五种： 
    1. 工厂方法模式  
        定义一个创建对象的接口，让子类决定将哪一个类实例化。使一个类实例化延迟到子类。
    2. 抽象工厂模式   
        提供一个创建一系列产品或相互依赖对象接口无需指定具体的类。     
    3. 单例模式  
        保证一个类仅有一个实例，并提供一个访问它的全局访问。
    4. 建造者模式  
        将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
    5. 原型模式  
        用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。
- 结构型模式，共七种：
    1. 适配器模式  
        将一个类的接口转换成客户希望的另一个接口，Adapter使原本由于接口不兼容而不能正常工作的类可以正常工作。
    2. 装饰器模式  
        动态地给一个对象添加一些额外的职责，就扩展功能而言，它比生成子类方式更加灵活。
    3. 代理模式  
        为其他对象提供一个代理以控制对这个对象的访问。
    4. 外观模式  
        为子系统中的一组接口提供一个一致的界面，Facade模式定义一个高层接口，这个接口使得这一子系统更加容易使用。
    5. 桥接模式  
        将抽象部分与实现部分分离，使它们可以独立变化。
    6. 组合模式  
        将对象组合成树形结构以表示 “部分-整体”的层次结构。它使得客户对单个对象和符合对象的使用具有一致性。
    7. 享元模式  
        运用共享技术有效支持大量细粒度对象。
- 行为型模式，共十一种：
    1. 策略模式  
        定义一系列算法，把他们封装起来，并且使它们可以相互替换，本模式使得算法的变化可以独立与使用它的客户端。
    2. 模板方法模式  
        定义一个操作中的算法骨架，而将一些步骤延迟到子类，Template Method使得子类可以不改变一个算法结构即可重新定义该算法某些特定步骤。
    3. 观察者模式  
        定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。
    4. 迭代器模式  
        提供一种方法顺序访问一个聚合对象中各个元素而又不暴露该对象内部表示。
    5. 责任链模式  
        为接触请求的发送者和接受者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条连传递该请求，知道有一个对象处理。
    6. 命令模式  
        将一个请求封装为一个对象，从而使可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消操作。
    7. 备忘录模式  
        在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象回复到保存的状态。
    8. 状态模式  
        允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎属于一个新的类。
    9. 访问者模式  
        表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
    10. 中介者模式  
        用一个中介对象来封装一系列对象交互，中介者使各对象不需要显示的相互引用，从而使得其耦合松散，而且可以独立的改变他们之间的交互。
    11. 解释器模式  
        给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中句子。
### 原则

1. 开闭原则（Open Close Principle）  
    开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。
2. 里氏代换原则（Liskov Substitution Principle）   
    1. 子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。
    2. 返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。
    如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。
    3. 还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。
    而不能声明抛出父类没有声明的异常。  
    一句话理解：所有使用父类的地方都可以被子类替换
3. 依赖倒转原则（Dependence Inversion Principle）  
    面向接口编程，依赖于抽象而不依赖于具体。
4. 接口隔离原则（Interface Segregation Principle）  
    使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，
    从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5. 迪米特法则（最少知道原则）（Demeter Principle）  
   一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6. 合成复用原则（Composite Reuse Principle）  
    当聚合和继成都可以实现时候，应该使用聚合。聚合由于继承。
    
### 总结
> 上面提到的23种是经典和常用的模式。在实际生产中按照需求总结提取使用。有利于提高代码和程序功能的扩展维护性。然而也不能一味的以使用模式而是用，这就本末倒置了。随着更深入的理解和学习设计模式，会渐渐意识到：设计模式
真正的的模式是 "无模式"。看似无招胜似有招。